;; Test if a sequence is not equal to each other
(defn not= (& args)
  (not (apply = args)))

;; Test if a collection is empty
(defn empty? (x)
  (or (= x ()) (= x (list)) (= x "")))

;; Test if a collection is non-empty
(defn non-empty? (x) (not (empty? x)))

;; Control Flow

(defn if (true? then else)
  (cond
   true? then
   true else))

(defn is-even? (x) (= 0 (% x 2)))

;; Func Tools

(defn zip (l r)
  (cond
   (or (empty? l) (empty? r)) ()
   true (cons
         (list (head l) (head r))
         (zip (tail r) (tail l)))))

;; Random

(defn dot-product (l r)
  (cond
   (or (empty? l) (empty? r)) 0.0
   true (+ (* (head l) (head r))
           (dot-product (tail l) (tail r)))))

(defn quicksort (l)
  (cond
   (empty? l) l
   true (bind
         (pivot (head l)
          rest  (tail l)
          le    (filter (fn (x) (<= x pivot)) rest)
          ge    (filter (fn (x) (> x pivot)) rest))
         (+ (quicksort le) (list pivot) (quicksort ge)))))

(defn fib-step (x)
  (tuple (nth 1 x) (+ (nth 0 x) (nth 1 x))))

;; Reduce (0 1) `num` times using fib-step to
;; generate the `num`'th fibonacci number

(defn fib (num)
  (nth 0 (reduce
          fib-step
          (tuple 0 1)
          (range num))))

;; Print one hundred fibonacci numbers
;;
;; Note: (take 100 (map fib (range)))
;; is an iterator which maps to Rust's iterators which
;; makes them very fast.
